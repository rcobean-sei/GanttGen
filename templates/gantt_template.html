<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1920, initial-scale=1.0">
    <title>Project Timeline - Gantt Chart</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        :root {
            --connector-width: 2px;
            
            /* Brand Colors - Reds */
            --red-1: #F01840;
            --red-2: #C01830;
            --red-3: #901226;
            --red-4: #600C1C;
            --red-5: #300810;
            
            /* Brand Colors - Purples */
            --purple-1: #D0C8C8;
            --purple-2: #A0949E;
            --purple-3: #705E74;
            --purple-4: #402848;
            --purple-5: #2A1C30;
            
            /* Brand Colors - Neutrals */
            --cream: #FFFFF8;
            --black: #141018;
            
            /* Accent color - can be overridden per palette */
            --accent-color: var(--black);
            --accent-border: transparent;
            --accent-border-width: 0px;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 10px;
            background-color: transparent;
        }
        
        .gantt-container {
            background: transparent;
            border-radius: 8px;
            padding: 15px;
            box-shadow: none;
            max-width: 1920px;
            width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }
        
        .chart-title-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0 0 15px 0;
        }
        
        .chart-title-logo {
            height: 28px;
            width: auto;
            flex-shrink: 0;
        }
        
        h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--black);
            margin: 0;
            letter-spacing: -0.5px;
        }
        
        .gantt-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .gantt-chart {
            border: 1px solid var(--purple-1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 0;
            position: relative;
        }
        
        
        .task-section {
            position: relative;
            overflow: visible; /* Allow connectors to extend past */
        }
        
        /* Clip container for milestone connectors */
        .milestone-clip-wrapper {
            position: relative;
            overflow: hidden;
        }
        
        .gantt-row {
            display: flex;
            border-bottom: 1px solid var(--purple-1);
            flex-shrink: 0;
        }
        
        .gantt-row:last-child {
            border-bottom: none;
        }
        
        .col-task {
            width: 380px;
            min-width: 380px;
            padding: 12px 16px;
            background: var(--cream);
            border-right: 1px solid var(--purple-1);
            border-left: var(--accent-border-width) solid var(--accent-border);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .task-name {
            font-weight: 600;
            font-size: 21px;
            color: var(--accent-color);
        }
        
        .subtasks {
            margin-top: 6px;
            padding-left: 4px;
        }
        
        .subtask {
            font-size: 16px;
            font-weight: 400;
            color: var(--purple-3);
            line-height: 1.3;
            margin-bottom: 3px;
            padding-left: 12px;
            position: relative;
        }
        
        .subtask:last-child {
            margin-bottom: 0;
        }
        
        .subtask::before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--purple-2);
        }
        
        .col-timeline {
            flex: 1;
            min-width: 0;
            position: relative;
        }
        
        /* Header row styling */
        .header-row {
            background: var(--black);
            color: var(--cream);
            border-bottom: 1px solid rgba(255,255,255,0.2);
            position: relative;
            z-index: 20; /* Ensure header is above connector lines */
        }
        
        .header-row .col-task {
            background: var(--black);
            border-right-color: rgba(255,255,255,0.2);
            color: var(--cream);
            font-size: 16px;
        }
        
        .header-row .col-timeline {
            display: flex;
            flex-direction: column;
        }
        
        .month-header {
            display: grid;
            height: 36px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .month-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 17px;
            border-right: 1px solid rgba(255,255,255,0.2);
            height: 100%;
        }
        
        .month-label:last-child {
            border-right: none;
        }
        
        .day-numbers {
            display: grid;
            height: 14px;
        }
        
        .day-number {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 15px;
            color: #fff;
            font-weight: 500;
        }
        
        .day-header {
            display: grid;
            height: 22px;
        }
        
        .day-tick {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #fff;
            border-right: 1px solid rgba(255,255,255,0.15);
        }
        
        .day-tick.weekend {
            color: #888;
        }
        
        .day-tick.month-boundary {
            border-right: 1px solid rgba(255,255,255,0.3);
        }
        
        .day-tick:last-child {
            border-right: none;
        }
        
        .day-tick.highlight {
            font-weight: bold;
        }
        
        .task-row .col-timeline {
            display: grid;
            align-items: center;
            background: var(--cream);
            min-height: 58px;
            position: relative;
        }
        
        .month-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            pointer-events: none;
        }
        
        .month-background.month-even {
            background-color: rgba(0, 0, 0, 0.03);
        }
        
        .month-background.month-odd {
            background-color: transparent;
        }
        
        .task-bar {
            height: 48px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--cream);
            font-weight: 600;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2);
            margin: 0 1px;
            padding: 4px 12px;
            position: relative;
            z-index: 10;
            overflow: hidden; /* Prevent text overflow */
            box-sizing: border-box; /* Include padding in height calculation */
        }
        
        .drop-shadow-enabled .task-bar {
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2), 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        /* Interrupted task bar segments - sharp edges on interrupted side */
        .task-bar-segment-left {
            border-radius: 4px 0 0 4px; /* Rounded only on left side */
            box-shadow: inset 1px 0 0 0 rgba(255,255,255,0.2), /* Left border only */
                        inset 0 1px 0 0 rgba(255,255,255,0.2), /* Top border */
                        inset 0 -1px 0 0 rgba(255,255,255,0.2); /* Bottom border */
        }
        
        .drop-shadow-enabled .task-bar-segment-left {
            box-shadow: inset 1px 0 0 0 rgba(255,255,255,0.2), /* Left border only */
                        inset 0 1px 0 0 rgba(255,255,255,0.2), /* Top border */
                        inset 0 -1px 0 0 rgba(255,255,255,0.2), /* Bottom border */
                        0 4px 12px rgba(0, 0, 0, 0.15); /* Drop shadow */
        }
        
        .task-bar-segment-left::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 1px;
            background: inherit;
            z-index: 2;
        }
        
        .task-bar-segment-right {
            border-radius: 0 4px 4px 0; /* Rounded only on right side */
            box-shadow: inset -1px 0 0 0 rgba(255,255,255,0.2), /* Right border only */
                        inset 0 1px 0 0 rgba(255,255,255,0.2), /* Top border */
                        inset 0 -1px 0 0 rgba(255,255,255,0.2); /* Bottom border */
        }
        
        .drop-shadow-enabled .task-bar-segment-right {
            box-shadow: inset -1px 0 0 0 rgba(255,255,255,0.2), /* Right border only */
                        inset 0 1px 0 0 rgba(255,255,255,0.2), /* Top border */
                        inset 0 -1px 0 0 rgba(255,255,255,0.2), /* Bottom border */
                        0 4px 12px rgba(0, 0, 0, 0.15); /* Drop shadow */
        }
        
        .task-bar-segment-right::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 1px;
            background: inherit;
            z-index: 2;
        }
        
        .task-bar-date {
            font-size: 17px; /* Fixed size - do not increase */
            line-height: 1.1; /* Tighter line height to fit within padding */
            white-space: nowrap; /* Prevent date text from wrapping */
            overflow: hidden; /* Prevent overflow */
        }
        
        /* Content positioning for split segments */
        .task-bar-content {
            position: absolute;
            top: 50%;
            left: 50%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Center both horizontally and vertically */
            display: flex;
            flex-direction: column;
            align-items: center;
            white-space: nowrap;
            z-index: 1;
            /* Ensure text doesn't overflow segment boundaries */
            max-width: calc(100% - 32px); /* Leave padding on both sides */
        }
        
        /* Align dates in split segments to same vertical position as regular task bars */
        .task-bar-segment-left,
        .task-bar-segment-right {
            justify-content: center; /* Match regular task bars */
            position: relative; /* Allow absolute positioning of content */
        }
        
        .task-bar-hours {
            font-size: 15px; /* Fixed size - do not increase */
            font-weight: 500;
            line-height: 1.1; /* Tighter line height to fit within padding */
            margin-top: 1px; /* Reduced margin to fit better */
            opacity: 0.95;
            overflow: hidden; /* Prevent overflow */
        }
        
        
        /* Break effect for task bars spanning pause periods */
        .task-bar-stripe-connector {
            position: absolute;
            height: 48px; /* Same height as task bar */
            top: 50%;
            transform: translateY(-50%);
            z-index: 11;
            pointer-events: none;
            background: repeating-linear-gradient(
                45deg,
                currentColor 0px,
                currentColor 1px,
                transparent 1px,
                transparent 4px
            );
            opacity: 0.6;
        }
        
        /* Ensure task bar content fits within available space */
        /* With 48px height and 4px top/bottom padding, available content height is 40px */
        /* Two lines: date (17px * 1.1 = 18.7px) + margin (1px) + hours (15px * 1.1 = 16.5px) = ~36.2px, fits within 40px */
        .task-bar > * {
            max-height: calc(100% - 8px); /* Account for 4px top + 4px bottom padding */
        }
        
        /* Font sizes are fixed to respect padding - do not increase these values */
        /* Current sizes: date 17px, hours/continued 15px with line-height 1.1 */
        /* Total content height: (17 * 1.1) + 1px margin + (15 * 1.1) = ~36.2px */
        /* Available space: 48px height - 8px padding = 40px, so fits comfortably */
        
        /* Remove task bar connector - using milestone connector instead */
        
        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: grid;
            pointer-events: none;
            z-index: 1;
        }
        
        .grid-line {
            border-right: 1px dashed rgba(0,0,0,0.08);
        }
        
        .grid-line.week-boundary {
            border-left: 1px dashed rgba(0,0,0,0.2);
        }
        
        .grid-line.month-boundary {
            border-right: 1px solid var(--purple-1);
        }
        
        .grid-line:last-child {
            border-right: none;
        }
        
        /* Milestones */
        #milestone-section {
            position: relative;
            overflow: visible;
        }
        
        .milestone-row {
            display: flex;
            margin-top: 15px;
        }
        
        .milestone-spacer {
            width: 380px;
            min-width: 380px;
        }
        
        .milestone-timeline {
            flex: 1;
            min-width: 0;
            display: grid;
            height: 65px;
            position: relative;
        }
        
        .milestone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            justify-self: center;
            position: relative;
            --milestone-color: var(--purple-4);
        }
        
        .milestone-label {
            background: var(--cream);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 500;
            color: var(--black);
            border: 2px solid var(--milestone-color, var(--purple-4));
            text-align: center;
            line-height: 1.3;
            white-space: nowrap;
            position: relative;
            transform: translateX(var(--connector-offset, 0px));
            --connector-height: 0px;
        }
        
        .drop-shadow-enabled .milestone-label {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        /* Connector from top of milestone label up to task section */
        .milestone-label::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: var(--connector-line-x, 50%);
            transform: translateX(-50%);
            width: 0;
            border-left: var(--connector-width, 2px) dotted var(--milestone-color, var(--purple-4));
            height: var(--connector-height, 0px);
            z-index: 1;
        }
        
        /* Pause period overlay with diagonal hash pattern */
        .pause-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 8px,
                rgba(160, 148, 158, 0.25) 8px,
                rgba(160, 148, 158, 0.25) 16px
            );
            pointer-events: none;
            z-index: 5; /* Above grid lines but below task bars */
        }
        
        .gantt-chart {
            position: relative; /* Ensure pause overlay can be positioned relative to this */
        }
    </style>
</head>
<body>
    <div class="gantt-container">
        <div class="chart-title-container">
            <svg class="chart-title-logo" viewBox="0 0 1200 1200" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill="#f01840" fill-rule="evenodd" d="M543.11,302.12c-174.64,0-344.13,141.38-344.13,370.01,0,284,214.56,412.46,242.76,427.87h0c-196-68.74-341.74-258.57-341.74-460.28,0-267.44,212.84-464.16,443.11-464.16s378.06,170.55,378.06,349.48c0,155.75-120.97,289.75-221.76,297.9,0,0,145.16-65.97,145.16-243.7,0-148.44-134.78-277.11-301.46-277.11ZM355.43,620.76c0-177.73,145.16-243.7,145.16-243.7-100.79,8.15-221.76,142.14-221.76,297.9,0,178.93,146.52,349.48,378.06,349.48s443.11-196.72,443.11-464.16c0-201.71-145.74-391.54-341.74-460.28h0c28.19,15.41,242.76,143.87,242.76,427.87,0,228.63-169.5,370.01-344.13,370.01s-301.46-128.67-301.46-277.11Z"/>
            </svg>
            <h1 id="chart-title">PROJECT TIMELINE</h1>
        </div>
        <div class="gantt-wrapper">
            <div id="gantt-chart" class="gantt-chart"></div>
            <div id="milestone-section"></div>
        </div>
    </div>

    <script>
    // ============================================================
    // CONFIGURATION - Injected from JSON config file
    // ============================================================
    
    const CONFIG = {{CONFIG}};
    
    // Apply accent styling from config (e.g., for purples palette variants)
    if (CONFIG.accentColor) {
        document.documentElement.style.setProperty('--accent-color', CONFIG.accentColor);
    }
    if (CONFIG.accentBorder) {
        document.documentElement.style.setProperty('--accent-border', CONFIG.accentBorder);
        document.documentElement.style.setProperty('--accent-border-width', '4px');
    }
    
    // Apply drop shadow class if enabled
    if (CONFIG.dropShadow !== false) {
        document.querySelector('.gantt-container').classList.add('drop-shadow-enabled');
    }
    
    let CURRENT_TOTAL_DAYS = 0;

    // Update pause period overlays to match current timeline dimensions
    function updatePauseOverlays() {
        if (!CONFIG.pausePeriods || CONFIG.pausePeriods.length === 0) return;
        
        const ganttChart = document.getElementById('gantt-chart');
        const firstTimelineCol = ganttChart?.querySelector('.col-timeline');
        if (!firstTimelineCol || !ganttChart) return;
        
        // Force layout recalculation
        firstTimelineCol.offsetHeight;
        
        // Get current dimensions
        const timelineRect = firstTimelineCol.getBoundingClientRect();
        const chartRect = ganttChart.getBoundingClientRect();
        const timelineLeft = timelineRect.left - chartRect.left;
        const timelineWidth = timelineRect.width;
        
        // Remove existing overlays
        const existingOverlays = ganttChart.querySelectorAll('.pause-overlay');
        existingOverlays.forEach(ov => ov.remove());
        
        // Create/update overlay for each pause period
        CONFIG.pausePeriods.forEach(pausePeriod => {
            const pauseStartCol = getDayIndex(pausePeriod.start, CONFIG.timelineStart);
            const pauseEndCol = getDayIndex(pausePeriod.end, CONFIG.timelineStart) + 1;
            const pauseLeftPercent = ((pauseStartCol - 1) / CURRENT_TOTAL_DAYS) * 100;
            const pauseWidthPercent = ((pauseEndCol - pauseStartCol) / CURRENT_TOTAL_DAYS) * 100;
            
            const overlayLeft = timelineLeft + (pauseLeftPercent / 100) * timelineWidth;
            const overlayWidth = (pauseWidthPercent / 100) * timelineWidth;
            
            const pauseOverlay = document.createElement('div');
            pauseOverlay.className = 'pause-overlay';
            pauseOverlay.style.left = `${overlayLeft}px`;
            pauseOverlay.style.width = `${overlayWidth}px`;
            pauseOverlay.style.top = '0';
            pauseOverlay.style.bottom = '0';
            ganttChart.appendChild(pauseOverlay);
        });
    }

    // ============================================================
    // CHART RENDERING ENGINE - No need to edit below this line
    // ============================================================

    // Utility functions
    function parseDate(str) {
        const [y, m, d] = str.split('-').map(Number);
        return new Date(y, m - 1, d);
    }

    function getISOWeekNumber(d) {
        // Copy date so don't modify original
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        // Set to nearest Thursday: current date + 4 - current day number
        // Make Sunday's day number 7
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay()||7));
        // Get first day of year
        var yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
        // Calculate full weeks to nearest Thursday
        var weekNo = Math.ceil(( ( (d - yearStart) / 86400000) + 1)/7);
        return weekNo;
    }

    function formatDateRange(start, end, format) {
        const s = parseDate(start);
        const e = parseDate(end);
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        if (format === 'numeric') {
            return `${s.getMonth()+1}/${s.getDate()}–${e.getMonth()+1}/${e.getDate()}`;
        }
        
        // Short format
        const sMonth = months[s.getMonth()];
        const eMonth = months[e.getMonth()];
        
        if (s.getMonth() === e.getMonth()) {
            return `${sMonth} ${s.getDate()}–${e.getDate()}`;
        }
        return `${sMonth} ${s.getDate()}–${eMonth} ${e.getDate()}`;
    }
    
    function formatStartDate(date, format) {
        const d = parseDate(date);
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        if (format === 'numeric') {
            return `${d.getMonth()+1}/${d.getDate()}–`;
        }
        
        // Short format
        const month = months[d.getMonth()];
        return `${month} ${d.getDate()}–`;
    }
    
    function formatEndDate(date, format) {
        const d = parseDate(date);
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        if (format === 'numeric') {
            return `–${d.getMonth()+1}/${d.getDate()}`;
        }
        
        // Short format
        const month = months[d.getMonth()];
        return `–${month} ${d.getDate()}`;
    }

    function getDayOfWeek(date) {
        const days = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
        return days[date.getDay()];
    }

    function daysBetween(start, end) {
        const s = parseDate(start);
        const e = parseDate(end);
        return Math.round((e - s) / (1000 * 60 * 60 * 24)) + 1;
    }

    function getDayIndex(date, timelineStart) {
        const d = parseDate(date);
        // timelineStart is the actual project start, but timeline has 1-day padding before it (in day mode)
        // In week mode, alignment is different
        const projectStart = parseDate(timelineStart);
        
        if (CONFIG.viewMode === 'week') {
            // In week mode, start is aligned to the Monday of the starting week
            // getDayOfWeek returns 0 for Sunday, 1 for Monday... 
            // We want Monday (1) to be the start. 
            // If day is 0 (Sunday), subtract 6 days. If 1 (Monday), subtract 0. If 2 (Tuesday), subtract 1.
            const day = projectStart.getDay();
            const diff = day === 0 ? 6 : day - 1; 
            const timelineStartAligned = new Date(projectStart);
            timelineStartAligned.setDate(projectStart.getDate() - diff);
            
            // Calculate days from aligned start
            const diffTime = d.getTime() - timelineStartAligned.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            // Return 1-based index
            return diffDays + 1;
        } else {
            // Day Mode logic (preserve existing padding behavior if desired, or switch to ISO)
            // Existing logic had 1 day padding. Let's keep it for day mode visual consistency.
            const s = new Date(projectStart);
            s.setDate(s.getDate() - 1); // Subtract 1 day for padding
            const diffTime = d.getTime() - s.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            return diffDays + 1; 
        }
    }

    // Build timeline data
    function buildTimelineData() {
        const projectStart = parseDate(CONFIG.timelineStart);
        const projectEnd = parseDate(CONFIG.timelineEnd);
        const isWeekMode = CONFIG.viewMode === 'week';
        
        let start, end;
        
        if (isWeekMode) {
            // Align start to the preceding Monday
            start = new Date(projectStart);
            const startDay = start.getDay(); // 0=Sun, 1=Mon
            const startDiff = startDay === 0 ? 6 : startDay - 1;
            start.setDate(start.getDate() - startDiff);
            
            // Align end to the following Sunday
            end = new Date(projectEnd);
            const endDay = end.getDay();
            const endDiff = endDay === 0 ? 0 : 7 - endDay;
            end.setDate(end.getDate() + endDiff);
        } else {
            // Day Mode: Subtract 1 day from start, add 1 day to end (padding)
            start = new Date(projectStart);
            start.setDate(start.getDate() - 1);
            
            end = new Date(projectEnd);
            end.setDate(end.getDate() + 1);
        }
        
        const totalDays = Math.round((end - start) / (1000 * 60 * 60 * 24)) + 1;
        
        const months = [];
        const days = [];
        // For week mode headers
        const weeks = []; 
        
        let currentDate = new Date(start);
        let currentMonth = null;
        let monthDays = 0;
        let monthIndex = -1;
        
        // Variables for week tracking
        let currentWeekNum = null;
        let weekDaysCount = 0;
        
        for (let i = 0; i < totalDays; i++) {
            // Month Logic
            const monthKey = `${currentDate.getFullYear()}-${currentDate.getMonth()}`;
            if (monthKey !== currentMonth) {
                if (currentMonth !== null) {
                    months[months.length - 1].days = monthDays;
                }
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                months.push({
                    name: `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`,
                    days: 0
                });
                currentMonth = monthKey;
                monthDays = 0;
                monthIndex++;
            }
            
            // Week Logic (ISO)
            const weekNum = getISOWeekNumber(currentDate);
            // Check if week changed. In ISO, weeks start on Monday.
            // But we iterate day by day. 
            // If we are in week mode, we group by weeks.
            // Or we just track weeks for the header.
            
            const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 6 = Saturday
            // ISO week starts Monday (1). Sunday (0) is end.
            const isWeekStart = dayOfWeek === 1; 
            const isWeekEnd = dayOfWeek === 0;
            
            // If it's the first day of the loop or a new week
            if (i === 0 || isWeekStart) {
                 if (i > 0 && weeks.length > 0) {
                     // Close previous week if needed? 
                     // Actually weeks array just holds week objects.
                 }
                 weeks.push({
                     number: weekNum,
                     startDayIndex: i, // 0-based index in the timeline
                     days: 0
                 });
            }
            if (weeks.length > 0) {
                weeks[weeks.length - 1].days++;
            }

            days.push({
                date: new Date(currentDate),
                dayOfWeek: getDayOfWeek(currentDate),
                isMonthEnd: false, // Will calculate later
                isWeekStart: isWeekStart, // ISO Monday
                monthIndex: monthIndex,
                weekIndex: weeks.length - 1
            });
            
            monthDays++;
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Set last month's days
        if (months.length > 0) {
            months[months.length - 1].days = monthDays;
        }
        
        // Adjust month names for visibility
        const minDaysForYear = isWeekMode ? 14 : 7; // Require more days in week mode to show label?
        months.forEach(month => {
            if (month.days < minDaysForYear) {
                month.name = '';
            }
        });
        
        // Mark month boundaries
        let dayIndex = 0;
        for (let m = 0; m < months.length - 1; m++) {
            dayIndex += months[m].days;
            if (dayIndex > 0 && dayIndex <= days.length) {
                days[dayIndex - 1].isMonthEnd = true;
            }
        }
        
        return { months, days, weeks, totalDays };
    }

    // Render the chart
    function renderChart() {
        const { months, days, weeks, totalDays } = buildTimelineData();
        CURRENT_TOTAL_DAYS = totalDays;
        const isWeekMode = CONFIG.viewMode === 'week';
        
        // Set title
        const projectTitle = CONFIG.title || 'PROJECT TIMELINE';
        document.getElementById('chart-title').textContent = projectTitle;
        
        // Build Grid Templates
        let mainGridTemplate;
        if (isWeekMode) {
            // In Week Mode, grid columns represent Weeks, not Days.
            // However, months might span partial weeks.
            // Simpler approach: Keep the grid as Days (high resolution) but visually hide them?
            // User requested: "weeks will exist as numbered weeks... but individual days will not show"
            // "Projects still start and end based on days... calculated internally for placement rather than being explicitly shown"
            
            // If we make the grid columns representing Weeks, placing tasks precisely (e.g. Tuesday start) requires percentage-based positioning inside the week cell OR using a fine-grained grid (7 columns per week).
            // Using 7 columns per week (Day grid) effectively *is* a Day grid, just with different headers.
            // Let's stick to Day Grid for layout precision, but styling changes to hide day ticks.
            // Wait, "Week resolution" implies the chart is physically smaller/compressed?
            // If it's compressed, 1 day column might be too small (e.g. 5px).
            // If we want it compressed, we should use Weeks as the grid unit.
            // Then place tasks using `left: (dayIndex / 7 * 100)%`.
            
            mainGridTemplate = weeks.map(w => '1fr').join(' '); // 1 column per week
        } else {
            mainGridTemplate = `repeat(${totalDays}, 1fr)`; // 1 column per day
        }
        
        const monthGridTemplate = months.map(m => {
            // For Month header, we need to span correctly.
            // If grid is Days: span = m.days
            // If grid is Weeks: span = m.days / 7 (approx).
            // Actually, for Week Mode, aligning Months to Weeks is tricky because months split weeks.
            // "weeks... will coincide with months as rendered"
            // Usually this means the Month header is above the Week header.
            // If we use CSS Grid with Week columns, a Month might span "1.5" columns which isn't possible directly with `grid-column: span`.
            // Absolute positioning for headers might be easier in Week mode?
            // OR: We stick to Day Grid (high res) even in Week Mode, just styled differently.
            // If we stick to Day Grid, we can just hide the day tick borders and labels.
            // This preserves all the logic for `grid-column` placement of tasks!
            // Let's try High-Res Week Mode (Day Grid, Week Headers).
            return `${m.days}fr`;
        }).join(' ');

        // -- Strategy Decision --
        // To support "projects longer than a couple months", we want to compress the width.
        // If we keep Day Grid, minimum column width might force scrolling.
        // If we switch to Week Grid (1 col = 1 week), we reduce columns by 7x.
        // This is much better for long projects.
        // So: Week Mode = Grid columns are Weeks. Tasks are positioned absolutely.
        
        // Recalculate templates if we are in Week Grid mode
        let headerHTML;
        
        if (isWeekMode) {
            // Week Grid Mode
            // Calculate absolute positions for Month Labels because they don't align with Week Grid lines
            // Month 1 has 13 days -> 1.85 weeks.
            
            const timelineWidthPercent = 100;
            let monthMarkers = months.map((m, i) => {
                // Calculate position based on day count
                // We know the total days.
                // We need to know previous days count.
                let prevDays = 0;
                for(let j=0; j<i; j++) prevDays += months[j].days;
                
                const left = (prevDays / totalDays) * 100;
                const width = (m.days / totalDays) * 100;
                return `<div class="month-label" style="position: absolute; left: ${left}%; width: ${width}%;">${m.name}</div>`;
            }).join('');

            headerHTML = `
                <div class="gantt-row header-row">
                    <div class="col-task">${projectTitle}</div>
                    <div class="col-timeline" style="position: relative; display: flex; flex-direction: column;">
                        <div class="month-header" style="position: relative; height: 50px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                            ${monthMarkers}
                        </div>
                        <div class="day-header" style="display: grid; grid-template-columns: ${mainGridTemplate}; height: 22px;">
                            ${weeks.map(w => {
                                return `<div class="day-tick week-tick" style="justify-content: center; border-right: 1px solid rgba(255,255,255,0.15);">${w.number}</div>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        } else {
            // Day Grid Mode (Original)
            headerHTML = `
                <div class="gantt-row header-row">
                    <div class="col-task">${projectTitle}</div>
                    <div class="col-timeline" style="position: relative;">
                        <div class="month-header" style="grid-template-columns: ${monthGridTemplate}">
                            ${months.map(m => `<div class="month-label">${m.name}</div>`).join('')}
                        </div>
                        <div class="day-numbers" style="grid-template-columns: ${mainGridTemplate}">
                            ${days.map((d, i) => {
                                const isMonday = d.date.getDay() === 1;
                                const dayNum = isMonday ? d.date.getDate() : '';
                                return `<div class="day-number">${dayNum}</div>`;
                            }).join('')}
                        </div>
                        <div class="day-header" style="grid-template-columns: ${mainGridTemplate}">
                            ${days.map((d, i) => {
                                const highlight = (i + 1) % 5 === 0; 
                                const isWeekend = d.date.getDay() === 0 || d.date.getDay() === 6;
                                const classes = ['day-tick'];
                                if (highlight) classes.push('highlight');
                                if (isWeekend) classes.push('weekend');
                                if (d.isMonthEnd) classes.push('month-boundary');
                                return `<div class="${classes.join(' ')}">${d.dayOfWeek}</div>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Create task rows
        let tasksHTML = CONFIG.tasks.map((task, originalIndex) => {
            const taskStart = new Date(task.start);
            const taskEnd = new Date(task.end);
            const label = formatDateRange(task.start, task.end, "short"); 
            const hours = task.hours !== undefined ? task.hours : 0;
            const hoursText = hours > 0 ? `${hours} hrs` : '';
            
            // Check if task spans across any pause period
            let intersectingPause = null;
            if (CONFIG.pausePeriods && CONFIG.pausePeriods.length > 0) {
                for (const pause of CONFIG.pausePeriods) {
                    const pauseStart = new Date(pause.start);
                    const pauseEnd = new Date(pause.end);
                    if (taskStart < pauseEnd && taskEnd > pauseStart) {
                        intersectingPause = pause;
                        break;
                    }
                }
            }
            
            // Create grid lines
            let gridLines = '';
            if (isWeekMode) {
                // One line per week
                gridLines = weeks.map(() => `<div class="grid-line" style="border-right: 1px dashed rgba(0,0,0,0.15);"></div>`).join('');
            } else {
                // One line per day
                gridLines = days.map((d, i) => {
                    const classes = ['grid-line'];
                    if (d.isWeekStart) classes.push('week-boundary'); // Bold line for ISO Monday
                    if (d.isMonthEnd) classes.push('month-boundary');
                    return `<div class="${classes.join(' ')}"></div>`;
                }).join('');
            }
            
            // Create month background cells (absolutely positioned)
            const monthBackgrounds = [];
            let currentMonthIndex = 0; // Fixed starting index
            if(months.length > 0) currentMonthIndex = 0; // Actually need proper tracking
            
            let accumulatedDays = 0;
            months.forEach((m, i) => {
                const monthClass = i % 2 === 0 ? 'month-even' : 'month-odd';
                const leftPercent = (accumulatedDays / totalDays) * 100;
                const widthPercent = (m.days / totalDays) * 100;
                monthBackgrounds.push(`<div class="month-background ${monthClass}" style="left: ${leftPercent}%; width: ${widthPercent}%;"></div>`);
                accumulatedDays += m.days;
            });
            
            // Create subtasks HTML
            const subtasksHTML = task.subtasks && task.subtasks.length > 0 
                ? `<div class="subtasks">${task.subtasks.map(st => `<div class="subtask">${st}</div>`).join('')}</div>`
                : '';
            
            // Render task bar(s)
            let taskBarsHTML = '';
            
            // Positioning Logic
            // In Day Mode: use Grid Columns (start/end indices)
            // In Week Mode: use Absolute Position (left/width %)
            
            const getPos = (date) => {
                // Returns 1-based day index relative to timeline start
                // Need to convert to percentage for Week Mode
                const idx = getDayIndex(date, CONFIG.timelineStart); // 1-based
                if (isWeekMode) {
                    // (idx - 1) / totalDays * 100
                    return ((idx - 1) / totalDays) * 100;
                }
                return idx; // Column index
            };
            
            // Helper to generate style string
            const getStyle = (sDate, eDate) => {
                if (isWeekMode) {
                    const left = getPos(sDate);
                    // End index is inclusive of the day, so eDate index + 1 for grid line, 
                    // but for day count difference:
                    // duration in days = (e - s) days + 1
                    // width% = duration / total * 100
                    // or simpler: endPos - startPos. 
                    // getDayIndex returns 1 for start. 
                    // If task is 1 day, start=1, end=1.
                    // left = 0. width = 1/total.
                    // getPos(end) returns start of that day. We need end of that day.
                    const startIdx = getDayIndex(sDate, CONFIG.timelineStart);
                    const endIdx = getDayIndex(eDate, CONFIG.timelineStart);
                    const durationDays = endIdx - startIdx + 1;
                    const width = (durationDays / totalDays) * 100;
                    return `left: ${left}%; width: ${width}%; position: absolute;`;
                } else {
                    const startCol = getDayIndex(sDate, CONFIG.timelineStart);
                    const endCol = getDayIndex(eDate, CONFIG.timelineStart) + 1;
                    return `grid-column: ${startCol} / ${endCol};`;
                }
            };

            if (intersectingPause) {
                // Split logic
                // ... (simplified for brevity, adapting existing logic)
                const segment1Start = task.start;
                const segment1End = intersectingPause.start; // Actually pause start is exclusive? existing logic used pause.start as end col
                // Original: segment1EndCol = getDayIndex(pause.start). 
                // Grid column end is exclusive. So task ends at start of pause day?
                // Pause block usually means "no work on this day".
                // If pause is 1 day (Fri), task 1 (Mon-Thu), task 2 (Mon-Fri).
                // If task spans pause, it stops before pause and resumes after.
                // Assuming pause dates are inclusive "days off".
                
                // Let's rely on date objects for calc
                // Segment 1: Task Start -> Pause Start (exclusive of Pause Start?)
                // Actually existing logic:
                // segment1EndCol = getDayIndex(intersectingPause.start)
                // If pause starts on day 5. index=5.
                // segment1 goes 1 / 5. Covers days 1,2,3,4. 
                // So pause start day is NOT included in segment 1. Correct.
                
                // Segment 2: Pause End -> Task End
                // segment2StartCol = getDayIndex(intersectingPause.end) + 1.
                // If pause ends day 5. index=5. start=6. 
                // So pause end day is NOT included. Correct.
                // NOTE: This assumes pause start/end are "days off".
                
                // We need Dates for getStyle if in Week Mode
                // But getStyle takes "Task End Date" (inclusive).
                // Segment 1 ends day BEFORE pause starts.
                const pStart = new Date(intersectingPause.start);
                const s1End = new Date(pStart); s1End.setDate(s1End.getDate() - 1);
                
                // Segment 2 starts day AFTER pause ends.
                const pEnd = new Date(intersectingPause.end);
                const s2Start = new Date(pEnd); s2Start.setDate(s2Start.getDate() + 1);
                
                // Styling
                const s1Style = getStyle(task.start, formatDateForInput(s1End)); 
                const s2Style = getStyle(formatDateForInput(s2Start), task.end);
                
                // Connector logic
                let connectorStyle = '';
                if (isWeekMode) {
                    const cLeft = ((getDayIndex(intersectingPause.start, CONFIG.timelineStart) - 1) / totalDays) * 100;
                    // Width covers pause duration
                    const pStartIdx = getDayIndex(intersectingPause.start, CONFIG.timelineStart);
                    const pEndIdx = getDayIndex(intersectingPause.end, CONFIG.timelineStart);
                    const pDur = pEndIdx - pStartIdx + 1;
                    const cWidth = (pDur / totalDays) * 100;
                    connectorStyle = `left: ${cLeft}%; width: ${cWidth}%;`;
                } else {
                    const cStart = getDayIndex(intersectingPause.start, CONFIG.timelineStart);
                    const cEnd = getDayIndex(intersectingPause.end, CONFIG.timelineStart) + 1;
                    // Reuse existing percent calculation from logic or grid?
                    // Existing logic used percentages for connector even in Grid mode.
                    const cLeft = ((cStart - 1) / totalDays) * 100;
                    const cWidth = ((cEnd - cStart) / totalDays) * 100;
                    connectorStyle = `left: ${cLeft}%; width: ${cWidth}%;`;
                }

                // ... (Content centering logic same as before, mostly style based)
                // Simplified content for now
                
                taskBarsHTML = `
                    <div class="task-bar task-bar-segment-left" data-task-index="${originalIndex}" style="${s1Style} background: ${task.color}; --task-line-color: ${task.color};">
                        <div class="task-bar-content">
                            <div class="task-bar-date">${label}</div>
                            ${hoursText ? `<div class="task-bar-hours">${hoursText}</div>` : ''}
                        </div>
                    </div>
                    <div class="task-bar-stripe-connector" style="${connectorStyle} color: ${task.color};"></div>
                    <div class="task-bar task-bar-segment-right" data-task-index="${originalIndex}" style="${s2Style} background: ${task.color}; --task-line-color: ${task.color};">
                    </div>
                `;
            } else {
                // Continuous
                const style = getStyle(task.start, task.end);
                taskBarsHTML = `
                    <div class="task-bar" data-task-index="${originalIndex}" style="${style} background: ${task.color}; --task-line-color: ${task.color};">
                        <div class="task-bar-date">${label}</div>
                        ${hoursText ? `<div class="task-bar-hours">${hoursText}</div>` : ''}
                    </div>
                `;
            }
            
            return `
                <div class="gantt-row task-row" data-task-index="${originalIndex}">
                    <div class="col-task">
                        <div class="task-name">${task.name}</div>
                        ${subtasksHTML}
                    </div>
                    <div class="col-timeline" style="grid-template-columns: ${mainGridTemplate}">
                        <div class="grid-lines" style="grid-template-columns: ${mainGridTemplate}">
                            ${gridLines}
                        </div>
                        ${monthBackgrounds.join('')}
                        ${taskBarsHTML}
                    </div>
                </div>
            `;
        }).join('');
        
        document.getElementById('gantt-chart').innerHTML = headerHTML + `<div class="task-section">${tasksHTML}</div>`;
        
        // Pause Overlays
        if (CONFIG.pausePeriods && CONFIG.pausePeriods.length > 0) {
            requestAnimationFrame(() => updatePauseOverlays());
        }
        
        // Milestones
        if (CONFIG.showMilestones && CONFIG.milestones.length > 0) {
            const milestonesHTML = `
                <div class="milestone-row">
                    <div class="milestone-spacer"></div>
                    <div class="milestone-timeline" style="grid-template-columns: ${mainGridTemplate}">
                        ${CONFIG.milestones.map((m, index) => {
                            // Positioning
                            let style = '';
                            const associatedTask = CONFIG.tasks[m.taskIndex];
                            const connectorColor = associatedTask ? associatedTask.color : '#0056b3';
                            
                            if (isWeekMode) {
                                const idx = getDayIndex(m.date, CONFIG.timelineStart);
                                // Center of day: (idx - 1 + 0.5)
                                const left = ((idx - 0.5) / totalDays) * 100;
                                style = `left: ${left}%; position: absolute; transform: translateX(-50%);`;
                            } else {
                                const col = getDayIndex(m.date, CONFIG.timelineStart);
                                style = `grid-column: ${col};`;
                            }
                            
                            const label = m.name.replace(/\n/g, '<br>');
                            return `
                                <div class="milestone" data-milestone-index="${index}" data-task-index="${m.taskIndex}" style="${style} --milestone-color: ${connectorColor};">
                                    <div class="milestone-label">${label}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
            document.getElementById('milestone-section').innerHTML = milestonesHTML;
            requestAnimationFrame(updateMilestoneConnectors);
        }
    }

    // Helper for date string
    function formatDateForInput(date) {
        return date.toISOString().split('T')[0];
    }

    
    function updateMilestoneConnectors() {
        const milestoneTimeline = document.querySelector('.milestone-timeline');
        if (!milestoneTimeline || CURRENT_TOTAL_DAYS === 0) return;
        
        // Force layout recalculation to ensure we get current, consistent values
        // Access offsetHeight to force a synchronous layout calculation
        milestoneTimeline.offsetHeight;
        
        // Read timeline dimensions - do this immediately after forcing layout
        const timelineRect = milestoneTimeline.getBoundingClientRect();
        const timelineWidth = timelineRect.width;
        const timelineRight = timelineRect.right;
        const timelineLeft = timelineRect.left;
        
        // Calculate cell width - ensure this is done with the current timeline width
        // Use a more precise calculation to avoid rounding errors
        const cellWidth = timelineWidth / CURRENT_TOTAL_DAYS;
        const minPadding = cellWidth; // One day's column width as padding

        const milestoneElements = document.querySelectorAll('.milestone');
        
        // Collect all layout data first, then calculate and apply in a second pass
        // This ensures all getBoundingClientRect() calls happen in the same layout frame
        // Read ALL bounding rects in one batch to ensure consistency
        const layoutData = [];
        const allRects = [];
        
        milestoneElements.forEach((el, index) => {
            const taskIndex = Number(el.getAttribute('data-task-index'));
            const milestoneLabel = el.querySelector('.milestone-label');
            const taskBar = document.querySelector(`.task-bar[data-task-index="${taskIndex}"]`);
            if (!milestoneLabel || !taskBar) return;

            // Store references for batch reading
            allRects.push({ el, milestoneLabel, taskBar, index, taskIndex });
        });
        
        // Read ALL bounding rects in a single batch - this ensures they're all from the same layout frame
        allRects.forEach(({ el, milestoneLabel, taskBar, index, taskIndex }) => {
            const milestoneRect = el.getBoundingClientRect();
            const labelRect = milestoneLabel.getBoundingClientRect();
            const barRect = taskBar.getBoundingClientRect();
            
            layoutData.push({
                index,
                taskIndex,
                milestoneLabel,
                taskBar,
                milestoneRect,
                labelRect,
                barRect
            });
        });
        
        // Now calculate and apply positions using the collected layout data
        layoutData.forEach(({ index, milestoneLabel, taskBar, milestoneRect, labelRect, barRect }) => {
            const milestone = CONFIG.milestones[index];
            const col = getDayIndex(milestone.date, CONFIG.timelineStart);
            
            // Calculate connector line position directly from column number and cell width
            // This is the target position where the connector line should be (center of the date column)
            const connectorLineX = timelineLeft + ((col - 1) * cellWidth) + (cellWidth / 2);

            const labelWidth = labelRect.width;
            
            // Get the label's natural center position (without transform offset)
            // The label is inside the milestone element, which is centered in its grid cell
            // So the label's natural center is at the milestone element's center
            const milestoneCenter = milestoneRect.left + (milestoneRect.width / 2);
            const labelNaturalCenter = milestoneCenter; // Label is centered in milestone due to align-items: center
            
            // Calculate where label would be if centered on connector line
            const centeredLabelLeft = connectorLineX - (labelWidth / 2);
            const centeredLabelRight = connectorLineX + (labelWidth / 2);
            
            // Calculate offset needed to move label from its natural position to target position
            let labelOffset = connectorLineX - labelNaturalCenter;
            
            // Check if centered label would extend past either edge and adjust
            if (centeredLabelLeft < timelineLeft + minPadding) {
                // Adjust label to be at least one day's width from the left edge
                const minLabelLeft = timelineLeft + minPadding;
                const adjustedLabelCenter = minLabelLeft + (labelWidth / 2);
                labelOffset = adjustedLabelCenter - labelNaturalCenter;
            } else if (centeredLabelRight > timelineRight - minPadding) {
                // Adjust label to be at least one day's width from the right edge
                const maxLabelRight = timelineRight - minPadding;
                const adjustedLabelCenter = maxLabelRight - (labelWidth / 2);
                labelOffset = adjustedLabelCenter - labelNaturalCenter;
            }
            
            // Calculate where connector line will be relative to the label's final left edge
            // Final label center = natural center + offset
            const finalLabelCenter = labelNaturalCenter + labelOffset;
            const finalLabelLeft = finalLabelCenter - (labelWidth / 2);
            const connectorLineXRelative = connectorLineX - finalLabelLeft;

            const connectorHeight = Math.max(0, labelRect.top - barRect.bottom + 4);

            // Apply all styles together
            milestoneLabel.style.setProperty('--connector-height', `${connectorHeight}px`);
            milestoneLabel.style.setProperty('--milestone-color', getComputedStyle(taskBar).getPropertyValue('--task-line-color') || taskBar.style.backgroundColor);
            milestoneLabel.style.setProperty('--connector-offset', `${labelOffset}px`);
            milestoneLabel.style.setProperty('--connector-line-x', `${connectorLineXRelative}px`);
        });
    }
    
    // Adjust task labels if they overflow
    function adjustTaskLabels() {
        document.querySelectorAll('.task-bar').forEach((bar, idx) => {
            // Check for split content wrapper
            const contentWrapper = bar.querySelector('.task-bar-content');
            if (contentWrapper) {
                // Already handled by CSS, but we keep this selector for future logic if needed
            }

            // Find the date element - might be direct child or inside .task-bar-content
            const dateEl = bar.querySelector('.task-bar-date');
            if (!dateEl) return;
            
            // Store original text if not already stored
            if (!dateEl.hasAttribute('data-original-text')) {
                dateEl.setAttribute('data-original-text', dateEl.textContent);
            }
            
            // Always reset to original text first to check if it fits now
            const originalText = dateEl.getAttribute('data-original-text');
            if (dateEl.textContent !== originalText) {
                dateEl.textContent = originalText;
            }
            
            // Check if overflowing
            // Logic: Compare text width (scrollWidth) against Parent Width (bar.clientWidth) minus padding buffer (e.g. 32px for CSS padding + 8px extra safety = 40px)
            if (dateEl.scrollWidth > (bar.clientWidth - 40)) {
                const taskIndex = bar.getAttribute('data-task-index');
                if (taskIndex !== null) {
                    const task = CONFIG.tasks[taskIndex];
                    if (task) {
                        // Switch to numeric format: M/D-M/D
                        const numericLabel = formatDateRange(task.start, task.end, 'numeric');
                        dateEl.textContent = numericLabel;
                    }
                }
            }
        });
    }

    // Debounce resize handler to prevent rapid recalculations during window resize
    let resizeTimeout;
    let resizeRAF;
    window.addEventListener('resize', () => {
        // Cancel any pending resize handlers
        if (resizeTimeout) clearTimeout(resizeTimeout);
        if (resizeRAF) cancelAnimationFrame(resizeRAF);
        
        // Use both debounce and requestAnimationFrame for smooth updates
        resizeTimeout = setTimeout(() => {
            resizeRAF = requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    updatePauseOverlays();
                    updateMilestoneConnectors();
                    adjustTaskLabels();
                });
            });
        }, 50); // 50ms debounce
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        renderChart();
        // Run label adjustment after render
        requestAnimationFrame(() => {
            adjustTaskLabels();
        });
    });
    </script>
</body>
</html>
