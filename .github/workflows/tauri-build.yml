name: Tauri Build with Caching

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force full rebuild (clear cache)'
        required: false
        default: 'false'
        type: boolean

env:
  CARGO_TERM_COLOR: always

permissions:
  contents: read

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            name: 'macOS-arm64'
          - platform: 'windows-latest'
            args: ''
            name: 'Windows-x64'

    runs-on: ${{ matrix.platform }}
    name: Build (${{ matrix.name }})

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Generate cache key from source files that affect the build
      - name: Generate build cache key
        id: cache-key
        shell: bash
        run: |
          # Hash files that would require a rebuild
          if [ "${{ matrix.platform }}" == "macos-latest" ]; then
            HASH=$(cat \
              tauri-app/src-tauri/Cargo.toml \
              tauri-app/src-tauri/Cargo.lock \
              tauri-app/src-tauri/tauri.conf.json \
              tauri-app/package.json \
              $(find tauri-app/src-tauri/src -type f -name "*.rs") \
              $(find tauri-app/src -type f) \
              $(find scripts -type f -name "*.js") \
              $(find templates -type f) \
              2>/dev/null | sha256sum | cut -d' ' -f1)
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "Build cache key: macos-build-$HASH"
          else
            HASH=$(cat \
              tauri-app/src-tauri/Cargo.toml \
              tauri-app/src-tauri/Cargo.lock \
              tauri-app/src-tauri/tauri.conf.json \
              tauri-app/package.json \
              2>/dev/null | sha256sum | cut -d' ' -f1)
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "Build cache key: windows-build-$HASH"
          fi

      # Try to restore cached build artifacts (excludes bundle dir so we can re-sign)
      - name: Restore build cache (macOS)
        if: matrix.platform == 'macos-latest' && github.event.inputs.force_rebuild != 'true'
        id: cache-macos
        uses: actions/cache@v4
        with:
          path: |
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/deps
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/build
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/.fingerprint
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/ganttgen-app
          key: macos-build-v2-${{ steps.cache-key.outputs.hash }}

      - name: Restore build cache (Windows)
        if: matrix.platform == 'windows-latest' && github.event.inputs.force_rebuild != 'true'
        id: cache-windows
        uses: actions/cache@v4
        with:
          path: |
            tauri-app/src-tauri/target/release/deps
            tauri-app/src-tauri/target/release/build
            tauri-app/src-tauri/target/release/.fingerprint
            tauri-app/src-tauri/target/release/ganttgen-app.exe
          key: windows-build-v2-${{ steps.cache-key.outputs.hash }}

      - name: Check cache status
        shell: bash
        run: |
          FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
          if [ "$FORCE_REBUILD" == "true" ]; then
            echo "⚠️ Force rebuild requested - ignoring cache"
            echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
          elif [ "${{ matrix.platform }}" == "macos-latest" ]; then
            if [ "${{ steps.cache-macos.outputs.cache-hit }}" == "true" ]; then
              echo "✓ Build cache HIT - Cargo will use cached artifacts (faster build)"
              echo "BUILD_CACHE_HIT=true" >> $GITHUB_ENV
            else
              echo "✗ Build cache MISS - full compilation required"
              echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
            fi
          else
            if [ "${{ steps.cache-windows.outputs.cache-hit }}" == "true" ]; then
              echo "✓ Build cache HIT - Cargo will use cached artifacts (faster build)"
              echo "BUILD_CACHE_HIT=true" >> $GITHUB_ENV
            else
              echo "✗ Build cache MISS - full compilation required"
              echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
            fi
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust stable
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin' || '' }}
          cache: false

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'tauri-app/src-tauri'
          cache-on-failure: true

      - name: Import Apple Code Signing Certificate
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        env:
          APPLE_CERTIFICATE: ${{ secrets.MAC_CERT_P12_BASE64 }}
          APPLE_CERT_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD }}
        run: |
          # Check if required secrets are available
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_CERT_PASSWORD" ]; then
            echo "::error::Code signing secrets not found. Add MAC_CERT_P12_BASE64 and MAC_CERT_PASSWORD secrets."
            exit 1
          fi

          # Create a temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Export keychain path and password for subsequent steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Create and configure the temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate to keychain
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERTIFICATE_PATH"

          # Import certificate
          security import "$CERTIFICATE_PATH" -k "$KEYCHAIN_PATH" -f pkcs12 -P "$APPLE_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign

          # Set the keychain as default and add to search list
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm -f "$CERTIFICATE_PATH"

          echo "Code signing certificate imported successfully"

      - name: Debug - List certificates in keychain
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "=== Certificates available for code signing ==="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"
          echo ""
          echo "=== Expected signing identity ==="
          echo "Looking for: $APPLE_SIGNING_IDENTITY"
          echo ""
          echo "=== Checking if expected identity exists ==="
          if security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -q "Developer ID Application"; then
            echo "✓ Developer ID Application certificate found"
          else
            echo "::error::No Developer ID Application certificate found in keychain!"
            echo "The .p12 file may contain the wrong certificate type."
            echo "Make sure you exported 'Developer ID Application' (not 'Apple Development')"
            exit 1
          fi
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}

      - name: Install root project dependencies
        run: npm ci

      - name: Install scripts dependencies
        run: npm ci
        working-directory: scripts

      - name: Install Playwright browser for PNG export
        run: npx playwright install chromium
        working-directory: scripts

      - name: Install Tauri app dependencies
        run: npm ci
        working-directory: tauri-app

      - name: Install ImageMagick (macOS)
        if: matrix.platform == 'macos-latest'
        run: brew install imagemagick

      - name: Download Node.js for bundling (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          # Download Node.js for macOS ARM64
          NODE_VERSION="20.18.1"
          NODE_URL="https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-darwin-arm64.tar.gz"
          NODE_PATH="tauri-app/src-tauri/node-bundle"

          echo "Downloading Node.js v${NODE_VERSION} for macOS ARM64..."
          curl -L "$NODE_URL" -o node.tar.gz

          echo "Extracting Node.js..."
          tar -xzf node.tar.gz

          # Create bundle directory and copy node binary
          mkdir -p "$NODE_PATH"
          cp "node-v${NODE_VERSION}-darwin-arm64/bin/node" "$NODE_PATH/node"
          chmod +x "$NODE_PATH/node"

          # Verify
          "$NODE_PATH/node" --version
          echo "Node.js bundled successfully for macOS"

          # Cleanup
          rm -rf node.tar.gz "node-v${NODE_VERSION}-darwin-arm64"

      - name: Add padding to macOS icon
        if: matrix.platform == 'macos-latest'
        run: |
          # macOS icons need ~10% padding for proper dock appearance
          # Resize icon to 80% and center it on a 1024x1024 canvas
          cd tauri-app/src-tauri/icons
          magick icon.png -resize 820x820 -gravity center -background none -extent 1024x1024 icon_padded.png
          mv icon_padded.png icon.png
          echo "Added padding to macOS icon"

      - name: Generate Icons
        run: npm run tauri:icon src-tauri/icons/icon.png
        working-directory: tauri-app

      - name: Ensure Node.js available for Tauri action
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Verify node and npm on runner
        run: |
          node --version
          npm --version

      - name: Build Tauri app (macOS with signing)
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        working-directory: tauri-app
        run: |
          # Configure keychain in the same shell that runs the build
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          echo "Keychain configured, starting build..."
          npm run tauri build -- --target aarch64-apple-darwin

      - name: Build Tauri app (macOS unsigned for PRs)
        if: matrix.platform == 'macos-latest' && github.event_name == 'pull_request'
        working-directory: tauri-app
        run: |
          echo "Building unsigned app for PR..."
          npm run tauri build -- --target aarch64-apple-darwin

      - name: Download Node.js for bundling (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          # Download Node.js portable for Windows
          $nodeVersion = "20.18.1"
          $nodeUrl = "https://nodejs.org/dist/v$nodeVersion/node-v$nodeVersion-win-x64.zip"
          $nodePath = "tauri-app/src-tauri/node-bundle"

          Write-Host "Downloading Node.js v$nodeVersion..."
          Invoke-WebRequest -Uri $nodeUrl -OutFile "node.zip"

          Write-Host "Extracting Node.js..."
          Expand-Archive -Path "node.zip" -DestinationPath "node-temp" -Force

          # Create bundle directory and copy only node.exe
          New-Item -ItemType Directory -Force -Path $nodePath
          Copy-Item "node-temp/node-v$nodeVersion-win-x64/node.exe" "$nodePath/node.exe"

          # Verify
          & "$nodePath/node.exe" --version
          Write-Host "Node.js bundled successfully"

          # Cleanup
          Remove-Item "node.zip" -Force
          Remove-Item "node-temp" -Recurse -Force

      - name: Build Tauri app (Windows)
        if: matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: tauri-app
          args: ${{ matrix.args }}

      - name: Verify bundled Node.js in Windows build
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          # Check if node.exe exists in the bundle
          $bundlePath = "tauri-app/src-tauri/target/release/node-bundle/node.exe"
          if (Test-Path $bundlePath) {
            Write-Host "Node.js successfully bundled at: $bundlePath"
            & $bundlePath --version
          } else {
            Write-Host "::warning::Node.js bundle not found at expected location"
            # List what's in the target directory
            Get-ChildItem -Path "tauri-app/src-tauri/target/release" -Recurse -Name | Select-Object -First 50
          }

      - name: Verify code signature
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "=== Verifying code signature ==="
          APP_PATH="tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/macos/GanttGen.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Looking for GanttGen.app..."
            find tauri-app/src-tauri/target -name "*.app" -type d 2>/dev/null || true
            APP_PATH=$(find tauri-app/src-tauri/target -name "GanttGen.app" -type d 2>/dev/null | head -n 1)
          fi

          if [ -z "$APP_PATH" ] || [ ! -d "$APP_PATH" ]; then
            echo "::error::GanttGen.app not found!"
            exit 1
          fi
          echo "Found app: $APP_PATH"

          # Show full signature details
          echo ""
          echo "=== Full signature details ==="
          codesign -dv --verbose=4 "$APP_PATH" 2>&1 || true

          # Verify signature is valid (cryptographic verification - this is the real test)
          echo ""
          echo "=== Verifying signature validity ==="
          if ! codesign -v "$APP_PATH" 2>&1; then
            echo "::error::Signature verification failed!"
            exit 1
          fi
          echo "✓ Signature is cryptographically valid"

          # Check for Developer ID signature using multiple indicators
          # Note: Must use --verbose=4 to get Authority lines in output
          echo ""
          echo "=== Checking for Developer ID certificate ==="

          # Check 1: TeamIdentifier should be present (not "not set")
          TEAM_ID=$(codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep "TeamIdentifier=" | cut -d= -f2)
          if [ -z "$TEAM_ID" ] || [ "$TEAM_ID" = "not set" ]; then
            echo "::error::App is NOT signed with a Developer ID certificate (no TeamIdentifier)!"
            echo "The APPLE_SIGNING_IDENTITY secret must be the exact certificate name from Keychain Access."
            exit 1
          fi
          echo "✓ TeamIdentifier present (value may be redacted in logs)"

          # Check 2: Apple Root CA should be in the certificate chain
          if ! codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep -q "Authority=Apple Root CA"; then
            echo "::error::Certificate chain does not include Apple Root CA!"
            exit 1
          fi
          echo "✓ Apple Root CA found in certificate chain"

          # Check 3: Look for Developer ID in the chain (intermediate cert)
          if codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep -q "Authority=Developer ID"; then
            echo "✓ Developer ID certificate found in chain"
          else
            echo "Note: Developer ID line may be redacted by GitHub (matches secret)"
            echo "Signature is valid with proper Apple certificate chain - proceeding"
          fi

          # Check what Gatekeeper thinks
          echo ""
          echo "=== Gatekeeper assessment ==="
          spctl -a -vv "$APP_PATH" 2>&1 || echo "spctl check failed (expected without notarization)"

      - name: Notarize macOS DMG
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Check if notarization secrets are available
          if [ -z "$APPLE_ID" ] || [ -z "$APPLE_PASSWORD" ] || [ -z "$APPLE_TEAM_ID" ]; then
            echo "::warning::Notarization secrets not configured. Skipping notarization."
            echo "To enable notarization, add these GitHub secrets:"
            echo "  - APPLE_ID: Your Apple Developer account email"
            echo "  - APPLE_PASSWORD: An app-specific password"
            echo "  - APPLE_TEAM_ID: Your 10-character Team ID"
            exit 0
          fi

          echo "=== Notarizing DMG ==="
          DMG_PATH=$(find tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/dmg -name "*.dmg" | head -n 1)
          if [ -z "$DMG_PATH" ]; then
            echo "::error::DMG not found!"
            exit 1
          fi
          echo "Found DMG: $DMG_PATH"

          # Submit for notarization
          echo "Submitting for notarization..."
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"

          # Verify
          echo "Verifying notarization..."
          xcrun stapler validate "$DMG_PATH"
          spctl -a -t open --context context:primary-signature -v "$DMG_PATH" || true

          echo "Notarization complete!"

      - name: Upload macOS DMG
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: GanttGen-${{ matrix.name }}
          path: tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/dmg/*.dmg
          retention-days: 7
          if-no-files-found: warn

      - name: Upload Windows installer
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: GanttGen-${{ matrix.name }}
          path: |
            tauri-app/src-tauri/target/release/bundle/nsis/*.exe
            tauri-app/src-tauri/target/release/bundle/msi/*.msi
          retention-days: 7
          if-no-files-found: warn

      - name: Cleanup Keychain
        if: always() && matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Use KEYCHAIN_PATH from GITHUB_ENV if available, fallback to default
          KEYCHAIN="${KEYCHAIN_PATH:-$RUNNER_TEMP/app-signing.keychain-db}"
          # Use -e to check existence (keychains can be files or directory bundles)
          if [ -e "$KEYCHAIN" ]; then
            security delete-keychain "$KEYCHAIN" || true
          fi
