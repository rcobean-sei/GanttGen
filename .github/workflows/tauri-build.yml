name: Build

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force full rebuild (clear cache)'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1'

permissions:
  contents: write  # Write permission needed for auto-committing icon updates

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            name: 'macOS-arm64'
          - platform: 'windows-latest'
            args: ''
            name: 'Windows-x64'

    runs-on: ${{ matrix.platform }}
    name: Build (${{ matrix.name }})

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for git describe

      - name: Check if release build
        id: check-release
        shell: bash
        run: |
          if git describe --tags --exact-match HEAD 2>/dev/null; then
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "✓ This is a release build (tagged commit)"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "ℹ This is a development build"
          fi

          # Get commit hash and datetime for build info
          COMMIT=$(git rev-parse --short=7 HEAD)
          DATETIME=$(date +"%Y%m%d_%H%M%S")
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "datetime=$DATETIME" >> $GITHUB_OUTPUT
          echo "Build info: $DATETIME_$COMMIT"

      # Generate cache key from source files that affect the build
      - name: Generate build cache key
        id: cache-key
        shell: bash
        run: |
          # Hash files that would require a rebuild
          if [ "${{ matrix.platform }}" == "macos-latest" ]; then
            HASH=$(cat \
              tauri-app/src-tauri/Cargo.toml \
              tauri-app/src-tauri/Cargo.lock \
              tauri-app/src-tauri/tauri.conf.json \
              tauri-app/package.json \
              $(find tauri-app/src-tauri/src -type f -name "*.rs") \
              $(find tauri-app/src -type f) \
              $(find scripts -type f -name "*.js") \
              $(find templates -type f) \
              2>/dev/null | sha256sum | cut -d' ' -f1)
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "Build cache key: macos-build-$HASH"
          else
            HASH=$(cat \
              tauri-app/src-tauri/Cargo.toml \
              tauri-app/src-tauri/Cargo.lock \
              tauri-app/src-tauri/tauri.conf.json \
              tauri-app/package.json \
              2>/dev/null | sha256sum | cut -d' ' -f1)
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "Build cache key: windows-build-$HASH"
          fi

      # Try to restore cached build artifacts (excludes bundle dir so we can re-sign)
      - name: Restore build cache (macOS)
        if: matrix.platform == 'macos-latest' && github.event.inputs.force_rebuild != 'true'
        id: cache-macos
        uses: actions/cache@v4
        with:
          path: |
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/deps
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/build
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/.fingerprint
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/ganttgen-app
          key: macos-build-v2-${{ steps.cache-key.outputs.hash }}

      - name: Restore build cache (Windows)
        if: matrix.platform == 'windows-latest' && github.event.inputs.force_rebuild != 'true'
        id: cache-windows
        uses: actions/cache@v4
        with:
          path: |
            tauri-app/src-tauri/target/release/deps
            tauri-app/src-tauri/target/release/build
            tauri-app/src-tauri/target/release/.fingerprint
            tauri-app/src-tauri/target/release/ganttgen-app.exe
          key: windows-build-v2-${{ steps.cache-key.outputs.hash }}

      - name: Check cache status
        shell: bash
        run: |
          FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
          if [ "$FORCE_REBUILD" == "true" ]; then
            echo "⚠️ Force rebuild requested - ignoring cache"
            echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
          elif [ "${{ matrix.platform }}" == "macos-latest" ]; then
            if [ "${{ steps.cache-macos.outputs.cache-hit }}" == "true" ]; then
              echo "✓ Build cache HIT - Cargo will use cached artifacts (faster build)"
              echo "BUILD_CACHE_HIT=true" >> $GITHUB_ENV
            else
              echo "✗ Build cache MISS - full compilation required"
              echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
            fi
          else
            if [ "${{ steps.cache-windows.outputs.cache-hit }}" == "true" ]; then
              echo "✓ Build cache HIT - Cargo will use cached artifacts (faster build)"
              echo "BUILD_CACHE_HIT=true" >> $GITHUB_ENV
            else
              echo "✗ Build cache MISS - full compilation required"
              echo "BUILD_CACHE_HIT=false" >> $GITHUB_ENV
            fi
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust stable
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin' || '' }}
          cache: false

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'tauri-app/src-tauri'
          cache-on-failure: true

      - name: Import Apple Code Signing Certificate
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        env:
          APPLE_CERTIFICATE: ${{ secrets.MAC_CERT_P12_BASE64 }}
          APPLE_CERT_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD }}
        run: |
          # Check if required secrets are available
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_CERT_PASSWORD" ]; then
            echo "::error::Code signing secrets not found. Add MAC_CERT_P12_BASE64 and MAC_CERT_PASSWORD secrets."
            exit 1
          fi

          # Create a temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Export keychain path and password for subsequent steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Create and configure the temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate to keychain
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERTIFICATE_PATH"

          # Import certificate
          security import "$CERTIFICATE_PATH" -k "$KEYCHAIN_PATH" -f pkcs12 -P "$APPLE_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign

          # Set the keychain as default and add to search list
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm -f "$CERTIFICATE_PATH"

          echo "Code signing certificate imported successfully"

      - name: Debug - List certificates in keychain
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "=== Certificates available for code signing ==="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"
          echo ""
          echo "=== Expected signing identity ==="
          echo "Looking for: $APPLE_SIGNING_IDENTITY"
          echo ""
          echo "=== Checking if expected identity exists ==="
          if security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -q "Developer ID Application"; then
            echo "✓ Developer ID Application certificate found"
          else
            echo "::error::No Developer ID Application certificate found in keychain!"
            echo "The .p12 file may contain the wrong certificate type."
            echo "Make sure you exported 'Developer ID Application' (not 'Apple Development')"
            exit 1
          fi
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}

      - name: Install root project dependencies
        run: npm ci

      - name: Install scripts dependencies
        run: npm ci
        working-directory: scripts

      - name: Install Tauri app dependencies
        run: npm ci
        working-directory: tauri-app

      - name: Generate Windows icon for README
        if: matrix.platform == 'macos-latest'
        run: |
          echo "▶ Generating Windows icon for README..."
          
          # Install icon generator dependencies
          cd tools/icon-generator
          npm ci
          
          # Generate Windows icon (1024x1024 with drop shadow)
          node generate-icon.js --config configs/windows.json --output output/icon-windows.png
          echo "✅ Windows icon generated"
          
          # Install sharp for image resizing (from root, it's in optionalDependencies)
          cd ../..
          npm install sharp --no-save || npm install sharp
          
          # Resize to 128x128
          node -e "
            const sharp = require('sharp');
            const fs = require('fs');
            const path = require('path');
            
            // Ensure assets directory exists
            const assetsDir = 'assets';
            if (!fs.existsSync(assetsDir)) {
              fs.mkdirSync(assetsDir, { recursive: true });
            }
            
            sharp('tools/icon-generator/output/icon-windows.png')
              .resize(128, 128, {
                fit: 'contain',
                background: { r: 255, g: 255, b: 248, alpha: 0 } // Transparent background
              })
              .toFile('assets/icon-128.png')
              .then(() => {
                console.log('✅ Icon resized to 128x128 and saved to assets/icon-128.png');
                // Verify file was created
                if (fs.existsSync('assets/icon-128.png')) {
                  const stats = fs.statSync('assets/icon-128.png');
                  console.log(\`   File size: \${(stats.size / 1024).toFixed(2)} KB\`);
                }
              })
              .catch(err => {
                console.error('Error resizing icon:', err);
                process.exit(1);
              });
          "

      - name: Verify icon and README
        if: matrix.platform == 'macos-latest'
        run: |
          echo "▶ Verifying icon generation and README reference..."
          
          # Verify icon file was created
          if [ -f "assets/icon-128.png" ]; then
            echo "✅ Icon file exists: assets/icon-128.png"
            ls -lh assets/icon-128.png
          else
            echo "⚠️ Icon file not found: assets/icon-128.png"
            exit 1
          fi
          
          # Verify README has icon reference
          if grep -q "assets/icon-128.png" README.md; then
            echo "✅ README contains icon reference"
          else
            echo "⚠️ Warning: README does not contain icon reference"
            echo "The icon reference should be in README.md but was not found"
          fi

      - name: Commit icon and README changes
        if: matrix.platform == 'macos-latest' && github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Stage the icon and README
          git add assets/icon-128.png README.md 2>/dev/null || true
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "ℹ️ No changes to commit (icon and README are up to date)"
          else
            echo "▶ Committing icon and README updates..."
            git commit -m "chore: update icon and README [skip ci]" || exit 0
            git push || echo "⚠️ Failed to push changes, but continuing workflow"
          fi

      - name: Generate Icons
        run: npm run tauri:icon src-tauri/icons/icon.png
        working-directory: tauri-app

      - name: Ensure Node.js available for Tauri action
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Verify node and npm on runner
        run: |
          node --version
          npm --version

      - name: Build Tauri app (macOS with signing)
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          BUILD_DATETIME: ${{ steps.check-release.outputs.datetime }}
          BUILD_COMMIT: ${{ steps.check-release.outputs.commit }}
          IS_RELEASE: ${{ steps.check-release.outputs.is_release }}
        working-directory: tauri-app
        run: |
          # Configure keychain in the same shell that runs the build
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          echo "Keychain configured, starting build..."
          npm run tauri build -- --target aarch64-apple-darwin

      - name: Build Tauri app (macOS unsigned for PRs)
        if: matrix.platform == 'macos-latest' && github.event_name == 'pull_request'
        env:
          BUILD_DATETIME: ${{ steps.check-release.outputs.datetime }}
          BUILD_COMMIT: ${{ steps.check-release.outputs.commit }}
          IS_RELEASE: ${{ steps.check-release.outputs.is_release }}
        working-directory: tauri-app
        run: |
          echo "Building unsigned app for PR..."
          npm run tauri build -- --target aarch64-apple-darwin

      - name: Build Tauri app (Windows)
        if: matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BUILD_DATETIME: ${{ steps.check-release.outputs.datetime }}
          BUILD_COMMIT: ${{ steps.check-release.outputs.commit }}
          IS_RELEASE: ${{ steps.check-release.outputs.is_release }}
        with:
          projectPath: tauri-app
          args: ${{ matrix.args }}

      - name: Verify code signature
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "=== Verifying code signature ==="
          APP_PATH="tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/macos/GanttGen.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Looking for GanttGen.app..."
            find tauri-app/src-tauri/target -name "*.app" -type d 2>/dev/null || true
            APP_PATH=$(find tauri-app/src-tauri/target -name "GanttGen.app" -type d 2>/dev/null | head -n 1)
          fi

          if [ -z "$APP_PATH" ] || [ ! -d "$APP_PATH" ]; then
            echo "::error::GanttGen.app not found!"
            exit 1
          fi
          echo "Found app: $APP_PATH"

          # Show full signature details
          echo ""
          echo "=== Full signature details ==="
          codesign -dv --verbose=4 "$APP_PATH" 2>&1 || true

          # Verify signature is valid (cryptographic verification - this is the real test)
          echo ""
          echo "=== Verifying signature validity ==="
          if ! codesign -v "$APP_PATH" 2>&1; then
            echo "::error::Signature verification failed!"
            exit 1
          fi
          echo "✓ Signature is cryptographically valid"

          # Check for Developer ID signature using multiple indicators
          # Note: Must use --verbose=4 to get Authority lines in output
          echo ""
          echo "=== Checking for Developer ID certificate ==="

          # Check 1: TeamIdentifier should be present (not "not set")
          TEAM_ID=$(codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep "TeamIdentifier=" | cut -d= -f2)
          if [ -z "$TEAM_ID" ] || [ "$TEAM_ID" = "not set" ]; then
            echo "::error::App is NOT signed with a Developer ID certificate (no TeamIdentifier)!"
            echo "The APPLE_SIGNING_IDENTITY secret must be the exact certificate name from Keychain Access."
            exit 1
          fi
          echo "✓ TeamIdentifier present (value may be redacted in logs)"

          # Check 2: Apple Root CA should be in the certificate chain
          if ! codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep -q "Authority=Apple Root CA"; then
            echo "::error::Certificate chain does not include Apple Root CA!"
            exit 1
          fi
          echo "✓ Apple Root CA found in certificate chain"

          # Check 3: Look for Developer ID in the chain (intermediate cert)
          if codesign -dv --verbose=4 "$APP_PATH" 2>&1 | grep -q "Authority=Developer ID"; then
            echo "✓ Developer ID certificate found in chain"
          else
            echo "Note: Developer ID line may be redacted by GitHub (matches secret)"
            echo "Signature is valid with proper Apple certificate chain - proceeding"
          fi

          # Check what Gatekeeper thinks
          echo ""
          echo "=== Gatekeeper assessment ==="
          spctl -a -vv "$APP_PATH" 2>&1 || echo "spctl check failed (expected without notarization)"

      - name: Notarize macOS DMG
        if: false  # Disabled - notarization is more trouble than it's worth
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Check if notarization secrets are available
          if [ -z "$APPLE_ID" ] || [ -z "$APPLE_PASSWORD" ] || [ -z "$APPLE_TEAM_ID" ]; then
            echo "::warning::Notarization secrets not configured. Skipping notarization."
            echo "To enable notarization, add these GitHub secrets:"
            echo "  - APPLE_ID: Your Apple Developer account email"
            echo "  - APPLE_PASSWORD: An app-specific password"
            echo "  - APPLE_TEAM_ID: Your 10-character Team ID"
            exit 0
          fi

          echo "=== Notarizing DMG ==="
          DMG_PATH=$(find tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/dmg -name "*.dmg" | head -n 1)
          if [ -z "$DMG_PATH" ]; then
            echo "::error::DMG not found!"
            exit 1
          fi
          echo "Found DMG: $DMG_PATH"

          # Submit for notarization and capture output
          echo "Submitting for notarization..."
          NOTARIZE_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait 2>&1) || true

          echo "$NOTARIZE_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$NOTARIZE_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Check if notarization succeeded
          if echo "$NOTARIZE_OUTPUT" | grep -q "status: Accepted"; then
            echo "✓ Notarization accepted!"
          else
            echo "::error::Notarization failed!"
            echo ""
            echo "=== Fetching notarization log for details ==="
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" 2>&1 || true
            fi
            exit 1
          fi

          # Staple the notarization ticket
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"

          # Verify
          echo "Verifying notarization..."
          xcrun stapler validate "$DMG_PATH"
          spctl -a -t open --context context:primary-signature -v "$DMG_PATH" || true

          echo "Notarization complete!"

      - name: Package macOS zip bundle
        if: matrix.platform == 'macos-latest'
        run: |
          chmod +x scripts/create_mac_zip_bundle.sh
          ./scripts/create_mac_zip_bundle.sh

      - name: Rename macOS artifacts (non-release)
        if: matrix.platform == 'macos-latest' && steps.check-release.outputs.is_release == 'false'
        run: |
          # Rename DMG files
          cd tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/dmg
          for file in *.dmg; do
            if [ -f "$file" ]; then
              # Extract base name and extension
              base="${file%.dmg}"
              newname="${base}_${{ steps.check-release.outputs.datetime }}_${{ steps.check-release.outputs.commit }}.dmg"
              mv "$file" "$newname"
              echo "Renamed: $file -> $newname"
            fi
          done
          
          # Rename ZIP files
          cd ../zip
          for file in *.zip; do
            if [ -f "$file" ]; then
              # Extract base name and extension
              base="${file%.zip}"
              newname="${base}_${{ steps.check-release.outputs.datetime }}_${{ steps.check-release.outputs.commit }}.zip"
              mv "$file" "$newname"
              echo "Renamed: $file -> $newname"
            fi
          done

      - name: Upload macOS artifacts
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: GanttGen-${{ matrix.name }}
          path: |
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/dmg/*.dmg
            tauri-app/src-tauri/target/aarch64-apple-darwin/release/bundle/zip/*.zip
          retention-days: 7
          if-no-files-found: warn

      - name: Rename Windows artifacts (non-release)
        if: matrix.platform == 'windows-latest' && steps.check-release.outputs.is_release == 'false'
        shell: pwsh
        run: |
          $datetime = "${{ steps.check-release.outputs.datetime }}"
          $commit = "${{ steps.check-release.outputs.commit }}"

          # Rename NSIS installers
          Get-ChildItem -Path "tauri-app/src-tauri/target/release/bundle/nsis/*.exe" | ForEach-Object {
            $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
            $ext = $_.Extension
            $newname = "${base}_${datetime}_${commit}${ext}"
            $newpath = Join-Path $_.DirectoryName $newname
            Move-Item $_.FullName $newpath
            Write-Host "Renamed: $($_.Name) -> $newname"
          }

          # Rename MSI installers
          Get-ChildItem -Path "tauri-app/src-tauri/target/release/bundle/msi/*.msi" | ForEach-Object {
            $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
            $ext = $_.Extension
            $newname = "${base}_${datetime}_${commit}${ext}"
            $newpath = Join-Path $_.DirectoryName $newname
            Move-Item $_.FullName $newpath
            Write-Host "Renamed: $($_.Name) -> $newname"
          }

      - name: Upload Windows installer
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: GanttGen-${{ matrix.name }}
          path: |
            tauri-app/src-tauri/target/release/bundle/nsis/*.exe
            tauri-app/src-tauri/target/release/bundle/msi/*.msi
          retention-days: 7
          if-no-files-found: warn

      - name: Cleanup Keychain
        if: always() && matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Use KEYCHAIN_PATH from GITHUB_ENV if available, fallback to default
          KEYCHAIN="${KEYCHAIN_PATH:-$RUNNER_TEMP/app-signing.keychain-db}"
          # Use -e to check existence (keychains can be files or directory bundles)
          if [ -e "$KEYCHAIN" ]; then
            security delete-keychain "$KEYCHAIN" || true
          fi
